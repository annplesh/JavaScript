/*
1. Напиши функцию, которая принимает строку и проверяет, является ли она палиндромом. 
Если да - функция возвращает true, если нет - false;
*/

function isPalindrome(str) {
    // Удаляем пробелы и приводим к нижнему регистру
    const cleaned = str.toLowerCase().replace(/\s/g, '');

    // Сравниваем строку с её перевёрнутой версией
    return cleaned === cleaned.split('').reverse().join('');
}

console.log(isPalindrome('Anita lava la tina'));
console.log(isPalindrome('Hola'));

/*
2. Напиши функцию, которая принимает строку (предложение) и 
находит первое самое короткое слово в ней и возвращает его;
*/

function findShortestWord(sentence) { // Объявляем функцию с именем findShortestWord, которая принимает один аргумент — строку sentence.
    if (typeof sentence !== 'string') return '';
    /*
    - Проверка типа: если sentence — не строка
    - !== 'string' — если sentence не строка, то return возвращает пустую строку ('') и функция останавливается
      Защита от невалидного ввода (например, число, null, undefined)
    - Результат: функция не ломается, работает безопасно
    */
    const words = sentence
        .trim()
        .split(/\s+/)
        .map(word => word.replace(/[^\wа-яё]/gi, ''))
        .filter(Boolean);
    /*
    .trim() — удаляет пробелы в начале и конце строки.

    .split(/\s+/) — делаем из строки массив слов, используя регулярное выражение \s +, 
    - \s — любой пробельный символ (пробел, табуляция, перенос строки и т.д.)
    - + — означает "один или более"

    .map(word => word.replace(/[^\wа-яё]/gi, ''));
    - удаляем всё, кроме букв и цифр

    .filter(Boolean);
    - удаляем пустые строки
    */
    // Проверка на пустой массив
    if (words.length === 0) return '';
    /* words.length === 0 — проверяет, пустой ли массив words
       Если в массиве нет ни одного слова, функция сразу возвращает пустую строку ('')
    */

    return words.reduce((shortest, current) => {
        return current.length < shortest.length ? current : shortest;
    }, words[0] || '');

    /*
    return words.reduce((shortest, current) =>
    - Начинаем метод reduce, который перебирает массив words.
    - shortest — аккумулятор, хранит текущее самое короткое слово.
    - current — текущее слово из массива, с которым сравниваем

    return current.length < shortest.length ? current : shortest;
    - Сравниваем длину current и shortest.
    - Если current короче — возвращаем его, иначе оставляем shortest.
    - Это значение становится новым shortest на следующем шаге

    words[0] || ''
    - чтобы избежать ошибки, если массив пуст
    */
}

console.log(findShortestWord("Какое небо голубое! Мы не стронники разбоя!"));

/*
3. Напиши функцию, которая форматирует строку с цифрами в телефонный номер.
Пример: createPhoneNumber(1234567890) → 8(123) 456 - 7890;
*/

function createPhoneNumber(userPhone) {
    // Приводим значение к строке и очищаем от всего, кроме цифр — на случай, если пользователь ввёл пробелы, дефисы или текст
    const digits = String(userPhone).replace(/\D/g, '');

    /*
    1. String(userPhone) - Преобразует вход в строку.
    - Если userPhone — число (1234567890), оно станет '1234567890'
    - Если это уже строка — ничего не меняется
    - Это нужно, чтобы потом применить .replace() — метод, доступный только строкам

    2. .replace(/\D/g, '') - Удаляет всё, что не является цифрой
    - \D — любой символ, который не цифра (0–9)
    - g — глобальный флаг: заменяет все такие символы, а не только первый
    - '123-456-7890' → '1234567890'
    - 'Тел: 123 456 7890' → '1234567890'
    */

    if (digits.length !== 10) {
        return 'Неверный формат: номер должен содержать 10 цифр'; // ранний выход если есть ошибка
    }

    /*
    - digits.length — длина строки, содержащей только цифры.
    - !== 10 — проверка, что длина не равна 10.
    - return '...' — если длина не соответствует, возвращается сообщение об ошибке
    */

    const areaCode = digits.slice(0, 3); // первые 3 цыфры
    const firstPart = digits.slice(3, 6); // следующие 3
    const secondPart = digits.slice(6); // последние 4

    return `8 (${areaCode}) ${firstPart}-${secondPart}`; // финальный return, он срабатывает только если предыдущие условия не вызвали выход
}

console.log(createPhoneNumber(1234567890));
console.log(createPhoneNumber("12-34-56"));

// 4. Напиши функцию, которая ищет минимальное и максимальное значение в массиве;

function findMinMax(numbers) {
    // Проверяем, что передан именно массив
    if (!Array.isArray(numbers)) {
        throw new TypeError('Аргумент должен быть массивом');
    }
    /*
    - Array.isArray(numbers) — проверяет, является ли numbers массивом.
    - ! — означает "не". То есть: если numbers не массив...
    - throw new TypeError(...) — выбрасывает ошибку, чтобы остановить выполнение и показать, что что-то пошло не так.
    */

    // Проверяем, что массив не пустой
    if (numbers.length === 0) {
        throw new Error('Массив не должен быть пустым');
    }
    /*
    - numbers.length === 0 — проверяет, пустой ли массив.
    - Если длина равна нулю, значит в массиве нет элементов.
    - throw new Error(...) — выбрасывает ошибку, но уже другого типа.
    */

    // Проверяем, что массив содержит только числа
    if (!numbers.every(num => typeof num === 'number' && !isNaN(num))) {
        throw new TypeError('Массив должен содержать только числа');
    }
    /*
    - Метод .every() проверяет, выполняется ли условие для каждого элемента массива.
      Если все элементы проходят проверку — возвращает true.
      Если хотя бы один не проходит — возвращает false.

    - num => typeof num === 'number' && !isNaN(num) - это функция-предикат, которая применяется к каждому элементу массива:
      typeof num === 'number' — элемент должен быть числом.
      !isNaN(num) — и не NaN, потому что NaN — это "не число", хоть и имеет тип "number".
      if (!numbers.every()) - если не все элементы массива — корректные числа, тогда
      выбрасывается ошибка - throw new TypeError()
    */

    let min = numbers[0]; // Инициализация с первого элемента массива, т.к. пока мы не знаем, какие ещё значения есть.
    let max = numbers[0];

    for (let i = 1; i < numbers.length; i++) {
        if (numbers[i] < min) min = numbers[i];
        if (numbers[i] > max) max = numbers[i];
    }
    /*
    - for (let i = 1; i < numbers.length; i++) {
      Цикл for начинается с i = 1, потому что numbers[0] уже использован.
      i < numbers.length — цикл идёт до конца массива.
      На каждом шаге мы сравниваем текущий элемент numbers[i] с текущими min и max.

    - if (numbers[i] < min) min = numbers[i];
      Если текущий элемент меньше min, обновляем min, т.е. нашли новое минимальное значение — запоминаем его.

      if (numbers[i] > max) max = numbers[i];
      Такая же логика как с min
    */

    return { min, max }; //  Возвращаем объект с найденными значениями
}

/*
5. *Напиши функцию, которая на вход принимает массив, 
а на выходе возвращает новый, отсортированный в порядке возрастания, массив. 
Попробуй реализовать алгоритм сортировки самостоятельно. 
Если не получается - почитай про bubble sort и попробуй реализовать её.
*/

function bubbleSort(numbers) {
    for (let i = 0; i < numbers.length; i++) {
        for (let j = 0; j < numbers.length - 1 - i; j++) {
            if (numbers[j] > numbers[j + 1]) {
                // Обмен значений
                [numbers[j], numbers[j + 1]] = [numbers[j + 1], numbers[j]];
            }
        }
    }
    return numbers;
}

console.log(bubbleSort([5, 2, 9, 1, 6]));

/*
1. function bubbleSort(numbers) {
- Объявляется функция bubbleSort
- Принимает один аргумент — массив чисел numbers

2. for (let i = 0; i < numbers.length; i++) {
- Внешний цикл: сколько раз нужно пройти по массиву

- let i = 0; - Инициализация: создаём переменную i с начальным значением 0
- i < numbers.length - цикл продолжается, пока i меньше длины массива (если numbers.length = 5, то i идёт от 0 до 4)
- i++ - Шаг после каждой итерации увеличивает i на 1 (i= i+1)

3. for (let j = 0; j < numbers.length - 1 - i; j++) {
- Внутренний цикл: сравнивает соседние элементы

- let j = 0 - Инициализация: начинаем с первого элемента массива
-  j < numbers.length - 1 - i - Сравниваем до предпоследнего элемента, минус уже отсортированные
   -1 — потому что мы сравниваем j с j + 1, и не хотим выйти за границы массива
   -i — потому что после каждой внешней итерации (i), один элемент "всплыл" в конец и уже на своём месте

4. if (numbers[j] > numbers[j + 1]) {
- Сравнивает два соседних элемента массива:
- numbers[j] — текущий элемент
- numbers[j + 1] — следующий элемент
- Если текущий больше, значит они стоят не по порядку
- Тогда нужно поменять их местами, чтобы отсортировать

5️. [numbers[j], numbers[j + 1]] = [numbers[j + 1], numbers[j]];
- Способ: деструктурирующее присваивание. 
  Оно позволяет поменять местами два значения в массиве без временной переменной.

- Правая часть
[numbers[j + 1], numbers[j]]
— создаёт массив из двух значений, но в обратном порядке.
- Левая часть:
[numbers[j], numbers[j + 1]]
— говорит: "положи эти два значения обратно в массив, но в новом порядке".

- В результате:
numbers[j] получает значение numbers[j + 1],
numbers[j + 1] получает значение numbers[j].
*/
