// 1. Напиши рекурсивную функцию для вычисления суммы всех элементов в массиве;

function sumArray(arr) { // Объявляем функцию с именем sumArray, 
    // принимающую один параметр — массив arr

    // Базовый случай: если массив пустой, сумма равна 0
    if (arr.length === 0) { // Проверяем, пуст ли массив. Это условие завершает рекурсию.
        return 0; // Если массив пустой, возвращаем 0 — это базовый случай.
    }
    /*
    Прямой ход рекурсии — углубление:
    sumArray([1, 2, 3, 4, 5]) → вызывает sumArray([2, 3, 4, 5])
    sumArray([2, 3, 4, 5]) → вызывает sumArray([3, 4, 5])
    sumArray([3, 4, 5]) → вызывает sumArray([4, 5])
    sumArray([4, 5]) → вызывает sumArray([5])
    sumArray([5]) → вызывает sumArray([])
    sumArray([]) → возвращает 0 (базовый случай)
    */

    // Рекурсивный случай: первый элемент + сумма оставшегося массива
    return arr[0] + sumArray(arr.slice(1));
    /*
    Обратный ход рекурсии — возврат значений:
    sumArray([]) → 0
    sumArray([5]) → 5 + 0 = 5
    sumArray([4, 5]) → 4 + 5 = 9
    sumArray([3, 4, 5]) → 3 + 9 = 12
    sumArray([2, 3, 4, 5]) → 2 + 12 = 14
    sumArray([1, 2, 3, 4, 5]) → 1 + 14 = 15
    */
}

console.log(sumArray([1, 2, 3, 4, 5])); // 15

// 2. Реализуй функцию для нахождения максимального элемента в массиве 
// с использованием рекурсии;

function findMax(arr) {
    // Базовый случай: если массив состоит из одного элемента, он и есть максимум
    if (arr.length === 1) { // Проверяем остался ли только один элемент в массиве,
        return arr[0]; // если да - значит мы дошли до базового случая в рекурсии


        //Почему базовый случай — один элемент?
        // Потому что, когда мы дошли до одного элемента, 
        // это значит, что все остальные уже были перебраны и 
        // элемент — последний кандидат на максимум, 
        // и теперь мы начинаем сравнивать его с предыдущими.
    }
    /*
    Прямой ход рекурсии — углубление:
    findMax([3, 7, 2, 9, 4]) → вызывает findMax([7, 2, 9, 4])
    findMax([7, 2, 9, 4]) → вызывает findMax([2, 9, 4])
    findMax([2, 9, 4]) → вызывает findMax([9, 4])
    findMax([9, 4]) → вызывает findMax([4])
    findMax([4]) → возвращает 4 (базовый случай)
    */

    // Рекурсивный случай: сравниваем первый элемент с максимумом оставшегося массива
    const restMax = findMax(arr.slice(1)); // Рекурсивно ищем максимум в оставшейся части массива (без первого элемента)
    return arr[0] > restMax ? arr[0] : restMax;
    // если return arr[0] > restMax верни - arr[0] — первый элемент текущего массива,
    // иначе — верни restMax — максимум, найденный в оставшейся части массива с помощью рекурсии.

    /*
    Обратный ход рекурсии — возврат значений:
    findMax([4]) → 4
    findMax([9, 4]) → max(9, 4) = 9
    findMax([2, 9, 4]) → max(2, 9) = 9
    findMax([7, 2, 9, 4]) → max(7, 9) = 9
    findMax([3, 7, 2, 9, 4]) → max(3, 9) = 9
    */
}

console.log(findMax([3, 7, 2, 9, 4])); // 9

// 4. А вот теперь нужно реализовать функцию для вычисления чисел Фибоначчи 
// с кэшированием через рекурсию! 

function createFibonacci() {
    // Кэш для хранения уже вычисленных значений
    const cache = {};

    // Внутренняя рекурсивная функция с кэшированием
    function fib(n) {
        // Проверка: есть ли значение в кэше
        if (n in cache) {
            return cache[n];
        }

        // Базовые случаи
        if (n === 0) return 0;
        if (n === 1) return 1;

        /*
        Прямой ход рекурсии для fibonacci(10)
        fibonacci(10)
        → fibonacci(9) + fibonacci(8)
        → fibonacci(9) → fibonacci(8) + fibonacci(7)
        → fibonacci(8) → fibonacci(7) + fibonacci(6)
        → fibonacci(7) → fibonacci(6) + fibonacci(5)
        → fibonacci(6) → fibonacci(5) + fibonacci(4)
        → fibonacci(5) → fibonacci(4) + fibonacci(3)
        → fibonacci(4) → fibonacci(3) + fibonacci(2)
        → fibonacci(3) → fibonacci(2) + fibonacci(1)
        → fibonacci(2) → fibonacci(1) + fibonacci(0)
        → fibonacci(1) → базовый случай → возвращают 1
        → fibonacci(0) → базовый случай → возвращают 0 
        */

        // Рекурсивный вызов с сохранением результата в кэш
        cache[n] = fib(n - 1) + fib(n - 2); // Формула Фибоначчи: fib(n - 1) + fib(n - 2) - вычисление двух предидущих чисел Фибоначчи
        return cache[n]; // Возвращаем результат, уже сохранённый в кэше, чтобы в будущем не вычислять fib(n) заново
        /*
        Обратный ход рекурсии — возврат значений и заполнение кэша:

        |  n  | Формула             | Сумма         | Сохраняется в кэш      |
        |-----|---------------------|---------------|------------------------|
        |  2  | F(1) + F(0)         | 1 + 0 = 1     | cache[2] = 1           |
        |  3  | F(2) + F(1)         | 1 + 1 = 2     | cache[3] = 2           |
        |  4  | F(3) + F(2)         | 2 + 1 = 3     | cache[4] = 3           |
        |  5  | F(4) + F(3)         | 3 + 2 = 5     | cache[5] = 5           |
        |  6  | F(5) + F(4)         | 5 + 3 = 8     | cache[6] = 8           |
        |  7  | F(6) + F(5)         | 8 + 5 = 13    | cache[7] = 13          |
        |  8  | F(7) + F(6)         | 13 + 8 = 21   | cache[8] = 21          |
        |  9  | F(8) + F(7)         | 21 + 13 = 34  | cache[9] = 34          |
        | 10  | F(9) + F(8)         | 34 + 21 = 55  | cache[10] = 55         |

        Каждое число строится из суммы двух предыдущих, и результат сохраняется в кэш.
        Это позволяет избежать повторных вычислений и ускоряет работу функции.
        */
    }

    // Возвращаем замыкание — доступ к `fib` с сохранённым кэшем
    return fib; // Возвращаем замыкание — функцию с доступом к кэшу
}

const fibonacci = createFibonacci();

console.log(fibonacci(10)); // 55

/* 
fibonacci(10)
├─ fibonacci(9)
│  ├─ fibonacci(8)
│  │  ├─ fibonacci(7)
│  │  │  ├─ fibonacci(6)
│  │  │  │  ├─ fibonacci(5)
│  │  │  │  │  ├─ fibonacci(4)
│  │  │  │  │  │  ├─ fibonacci(3)
│  │  │  │  │  │  │  ├─ fibonacci(2)
│  │  │  │  │  │  │  │  ├─ fibonacci(1) → базовый случай → 1
│  │  │  │  │  │  │  │  └─ fibonacci(0) → базовый случай → 0
│  │  │  │  │  │  │  └─ cache[2] = 1
│  │  │  │  │  │  └─ cache[3] = 2
│  │  │  │  │  └─ cache[4] = 3
│  │  │  │  └─ cache[5] = 5
│  │  │  └─ cache[6] = 8
│  │  └─ cache[7] = 13
│  └─ cache[8] = 21
└─ cache[9] = 34

→ cache[10] = 55
*/