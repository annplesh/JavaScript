// 1. Напиши функцию, которая создает и возвращает другую функцию. 
// Внутренняя функция должна иметь доступ к переменной, 
// объявленной во внешней функции, даже после завершения внешней функции;

function createCounter() { // Объявляем функцию внешнюю функцию
  let count = 0; // let count = 0; // Локальная переменная, доступная внутренней функции через замыкание, даже после завершения createCounter

  // Возвращаем внутреннюю функцию, которая будет иметь доступ к переменной count
  // Даже после завершения работы createCounter, эта функция "помнит" значение count
  return function () {
    count++; // Увеличиваем значение count
    return count; // Возвращаем обновлённое значение
  };
}

const counter = createCounter(); // Сохраняем возвращённую функцию в переменную counter

console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3

// Вызываем функцию, сохранённую в counter.
//  Она увеличивает count и возвращает новое значение.
// И она "помнит" count, потому что была создана внутри creatCounter() - это и есть замыкание.

// 2. Реализуй пример с несколькими вложенными функциями, 
// где каждая функция использует переменные из своего собственного 
// и внешних лексических окружений;

// Внешняя функция — создаёт лексическое окружение и возвращает вложенную функцию
function createGreeting() {
  let greetingWord = 'Привет'; // greetingWord доступна всем вложенным функциям

  // Вложенная функция принимает имя и возвращает ещё одну функцию
  return function withName(name) {
    // Форматируем имя: первая буква заглавная, остальное — как есть
    let formattedName = name.charAt(0).toUpperCase() + name.slice(1);

    // Ещё одна вложенная функция — принимает роль и возвращает финальное приветствие
    return function withRole(role) {
      // Проверяем, является ли роль 'admin'
      // Если да — выводим 'администратор', иначе — 'пользователь'
      let roleLabel = role === 'admin' ? 'администратор' : 'пользователь';

      // Собираем финальное приветствие, используя переменные из всех уровней
      return `${greetingWord}, ${formattedName}! Вы вошли как ${roleLabel}.`;
    };
  };
}

// Создаём приветствие для Анны
const greetAnna = createGreeting()('анна'); // createGreeting → withName('анна')
console.log(greetAnna('admin')); // Привет, Анна! Вы вошли как администратор.

// Создаём приветствие для Ивана
const greetIvan = createGreeting()('иван');
console.log(greetIvan('user')); // Привет, Иван! Вы вошли как пользователь.

// 3*. Тебе нужно написать функцию для вычисления чисел Фибоначчи 
// с использованием цикла и кэширования.

//Числа Фибоначчи — это последовательность, в которой каждое число является суммой двух предыдущих чисел.
// Кэширование необходимо для того, чтобы избежать повторных вычислений одних и тех же значений, 
// что значительно ускорит работу функции.
// Кэширование реализуем с помощью только что изученных замыканий:)

// Функция должна возвращать другую функцию, 
// которая принимает число `n` и возвращает`n` - е число Фибоначчи. 
// Внутренняя функция должна использовать кэширование 
// для хранения уже вычисленных значений чисел Фибоначчи.

// Реализация должна быть через цикл, НЕ через рекурсию!

function createFibonacciCalculator() { // создаем функцию-генератор createFibonacciCalculator, 
  // которая возвращает вложенную функцию fibonacci(n).

  const cache = {}; // Создаём пустой объект, в который будут записываться уже вычисленные числа Фибоначчи.

  return function fibonacci(n) {
    // Для первых двух чисел Фибоначчи вычисления не требуются,
    // так как они являются стартовыми значениями для построения всей последовательности.
    // Поэтому их обрабатываем вручную.
    if (n === 0) return 0;
    if (n === 1) return 1;

    // Проверяем, есть ли уже вычисленное значение в кэше.
    // Если оно есть — сразу возвращаем, чтобы не выполнять повторные расчёты.
    if (n in cache) {
      return cache[n];
    }

    // Инициализируем первые два числа Фибоначчи: F(0) = 0 и F(1) = 1.
    // Это стартовые значения, от которых начинается построение последовательности.
    // Они будут использоваться для вычисления следующих чисел в цикле.
    let prev = 0;
    let curr = 1;

    // Вычисляем от 2 до n
    for (let i = 2; i <= n; i++) { // цикл, который говорит:
      // «Начни с i = 2 и повторяй, пока i не станет больше n
      // На каждом шаге увеличивай i на 1»
      // 
      const next = prev + curr; // вычисляем следующее число Фибоначчи
      cache[i] = next; // сохраняем в кэш
      prev = curr; // теперь curr становится новым prev
      curr = next; // а next — новым curr для следующего шага.
      // Это позволяет на каждом шаге складывать два последних числа.
    }

    return cache[n];
    // Возвращаем n-е число Фибоначчи из кэша.
    // Оно было вычислено в цикле и сохранено заранее.
    // Благодаря кэшированию повторные вызовы работают мгновенно.

  };
}

// Инициализируем калькулятор Фибоначчи через фабричную функцию.
// Она возвращает функцию fibonacci(n), которая сохраняет промежуточные значения в кэше.
// Кэш реализован через замыкание, что позволяет избежать повторных вычислений.
const fibonacci = createFibonacciCalculator();

console.log(fibonacci(0));  // 0
console.log(fibonacci(1));  // 1
console.log(fibonacci(5));  // 5
console.log(fibonacci(10)); // 55
console.log(fibonacci(50)); // 12586269025

// Цикл от 2 до n: на каждом шаге вычисляем следующее число Фибоначчи.
// Используем два предыдущих значения: prev и curr.
// next = prev + curr — это новое число, которое сохраняем в кэш.
// Затем сдвигаем окно: prev ← curr, curr ← next.
// Пример шагов:
// i = 2  → prev = 0,  curr = 1  → next = 1   → F(2)  = 1
// i = 3  → prev = 1,  curr = 1  → next = 2   → F(3)  = 2
// i = 4  → prev = 1,  curr = 2  → next = 3   → F(4)  = 3
// i = 5  → prev = 2,  curr = 3  → next = 5   → F(5)  = 5
// i = 6  → prev = 3,  curr = 5  → next = 8   → F(6)  = 8
// i = 7  → prev = 5,  curr = 8  → next = 13  → F(7)  = 13
// i = 8  → prev = 8,  curr = 13 → next = 21  → F(8)  = 21
// i = 9  → prev = 13, curr = 21 → next = 34  → F(9)  = 34
// i = 10 → prev = 21, curr = 34 → next = 55  → F(10) = 55

// !Последовательность Фибоначчи используется для демонстрации мемоизации, динамического программирования,
// !а также в реальных задачах: Fibonacci Search, визуализация спиралей, анализ деревьев,
// !технический анализ в трейдинге и градуированная нагрузка в тестировании.
// !Здесь мы используем её для отработки кэширования и пошагового вычисления.